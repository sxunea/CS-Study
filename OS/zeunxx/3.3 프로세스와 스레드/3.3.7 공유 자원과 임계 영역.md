# 공유 자원과 임계 영역

## 공유 자원 Shared Resource

여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등의 데이터 

공동으로 이용되므로 누가 언제 데이터를 읽고 쓰는지에 따라 결과가 다를 수 있음

- **경쟁 상태 Race Condition**: 공유 자원을 두개 이상의 프로세스가 동시에 읽거나 쓰는 상황
  - 공유 자원 접근 순서에 따라 실행 결과가 달라짐

<br>

## 임계 구역 Critical Section

여러 프로세스가 공유하는 데이터에 접근하는 **Code 영역**

한 번에 오직 하나의 프로세스만이 임계구역에 진입 가능


<br>

### 임계 구역 해결 조건

**Mutual Exclution 상호 배제**
- 만약 프로세스 A가 임계 구역에 진입해 있다면, 다른 모든 프로세스는 진입할 수 없어야 한다.
- 데이터의 일관성을 유지하기 위해 필요

<br>

![image](https://github.com/zeunxx/algorithm/assets/81572478/11a8d621-3839-47d2-b26c-f04aeebac583)



✅ mutual exclusion 위배 
- 상황: 임계구역에 들어가기 전에 다른 프로세스가 들어가 있는지 여부를 flag를 통해 파악. 만약 비었다면, 자신의 flag를 최신화 후 진입
  - P0가 실행되기 전에 P1의 flag를 보고 while문 진입
  - P0가 flag를 최신화 하기 전에 선점되어 잠시 멈출때 P1은 그 사이에 임계구역 진입
  - 뒤늦게 P0가 flag를 최신화 해도 임계구역에 두 프로세스 진입 = Mutual Exclution 위배

<Br>

**Progress 진행**
- 한 프로세스가 임계 구역에 진입한 후 빠져나오면 기다리고 있던 프로세스들 중 하나는 반드시 임계 구역에 접근해야 한다.
- 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다.
- 다음 프로세스로 진행되어 프로그램이 정상적으로 실행되기 위해 필요



![image](https://github.com/zeunxx/algorithm/assets/81572478/e4b757cb-00da-404d-8bf3-3ac42f9beb7d)


✅ progress 위배
- 상황: 프로세스 P0가 자신의 차례에 임계구역에 들어가 작업을 수행하고, 다음 차례에 P1이 들어가서 작업 수행
  - 앞 순서의 프로세스가 임계 구역 진입 전에 죽어서 종료된다면 다음 순서의 프로세스는 자신의 차례가 오지 않아 임계 구역 진입 불가 = progress 위배
  - 한 프로그래스가 두번 연속 임계 구역에 들어갈 경우 progress 위배 

<br>




**Bounded Waiting 유한한 대기**
- 프로세스가 임계 구역에 유한 시간 내에 진입해야 한다.
- 한 프로세스가 긴 시간동안 실행되지 않는 문제(기아 상태)를 해결하기 위해 필요 


![image](https://github.com/zeunxx/algorithm/assets/81572478/f0cd85f7-9650-47a9-b48e-1ec0d9e0d251)



✅ Bounded Waiting, Progress 이배
- 상홍: 이전의 상황을 해결하기 위해, while 진입 전에 flag 최신화
  - P0가 최신화 후에 선점되어 잠시 멈추면(while 돌기 전에), P1은 flag를 최신화 하고 while 수행
  - P0가 다시 실행하려는데 P1의 flag때문에 while문을 돌고 두 프로세스 모두 임계구역 진입 불가


<br><Br>


## 동기화 도구

### 뮤텍스 Mutex

공유된 자원의 데이터 혹은 임계 영역 등에 하나의 프로세스/스레드가 접근하는 것을 막아준다.

이때, 동기화 대상이 **하나**

- 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행(상호 배제) 되게 하는 기술
- 한 프로세스에 의해 소요될 수 있는 key를 기반으로 한 상호배제 기법. key에 해당하는 객체가 있어, 이 객체를 소유한 프로세스/스레드만이 공유 자원에 접근

<br>

![image](https://github.com/zeunxx/algorithm/assets/81572478/d91fa0d9-ea61-4b2a-93eb-f053e0eefd79)


프로세스/스레드가 **공유 자원을 lock()을 통해 잠금 설정하고, 사용한 후에는 unlock()을 통해 잠금 해제**하는 객체

잠금이 설정되면 다른 프로세스나 스레드는 잠긴 코드 영역에 접근할 수 없고 해제시 접근 가능

- 뮤텍스는 **화장실이 하나**밖에 없는 식당 = 카운터에 **키가 있으면 화장실에 사람이 없고**, 카운터에 **키가 없으면 화장실에 사람이 존재**
  - 사람 = 프로세스
  - 키 = 공유자원에 접근하기 위해 필요한 object
  - 화장실 = 공유자원


<br><br>

### 세마포어 Semaphore

공유된 자원의 데이터 혹은 임계 영역 등에 하나의 프로세스/스레드가 접근하는 것을 막아준다.

이때, 동기화 대상이 **하나 이상** 

- 사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 상호배제 달성
- 공유 자원에 접근할 수 있는 **프로세스의 최대 허용치만큼 동시에 사용자 접근 가능**, 각 프로세스는 세마포어의 값을 확인하고 변경 가능

<br>

![image](https://github.com/zeunxx/algorithm/assets/81572478/ca1ecac4-fa9d-47a2-a173-cad32b55b358)


세마포어는 일반화된 뮤텍스로, 간단한 정수 값과 wait()함수(P함수) 및 signal()함수(V함수)로 공유 자원에 대한 접근 처리 
- wait() : 자신의 차례가 올 때까지 기다리는 함수
- signal() : 다음 프로세스로 순서를 넘겨주는 함수


- 세마포어는 **화장실이 여러개**인 식당. 화장실 입구에는 **빈 칸 개수**를 보여줌. = 빈 칸의 개수가 1개 이상이라면 **빈칸의 개수를 하나 뺀 후 화장실에 입장**, **나올때 빈칸의 개수 하나 더함**.
- **모든 칸에 사람이 들어가면** 빈칸의 개수는 **0**, 이때 화장실에 들어가고자 한다면 빈**칸의 개수가 양수로 바뀔때까지 대기**
  - 빈 칸 개수 : 현재 공유자원에 접근할 수 있는 프로세스/스레드 수


<br><br>

### Mutex vs. Semaphore

가장 큰 차이점은 동기화 대상의 개수 (즉, 화장실 개수)

- mutex는 동기화 대상이 오직 1개일때, semaphore는 동기화 대상이 1개 이상일때
- mutex는 자원을 소유할 수 있고 책임을 가지는데, semaphore는 자원 소유 불가
- mutex는 상태가 0 혹은 1 이므로 lock을 가질 수 있고, 소유하는 스레드만이 mutex 해제 가능, semaphore는 semaphore를 소유하지 않는 스레드가 semaphore 해제
- semaphore는 시스템 범위에 걸쳐있고, 파일 시스템상의 파일로 존재, mutex는 프로세스 범위를 가지며 프로세스 종료시 자동으로 clean up


<br><br>

### 바이너리 세마포어 Binary Semaphore

0과 1의 두가지 값만 가질 수 있는 세마포어.

뮤텍스는 잠금을 기반으로 상호배제가 일어나는 **잠금 메커니즘**을 가지고, 세마포어는 신호를 기반으로 상호배제가 일어나는 **신호 메커니즘**

- 여기서 신호는 휴대폰으로 노래를 듣다가 친구로부터 전화가 오면 노래가 중지되고 통화 처리 작업에 관한 인터페이스가 등장하는 것
  - 따라서 semaphore는 semaphore를 소유하지 않는 스레드(전화)가 semaphore 해제


<br><br>

### 카운팅 세마포어 Counting Semaphore

여러개의 값을 가질 수 있는 세마포어, 여러 자원에 대한 접근을 제어하는데 사용


<br><br>

### 모니터 Monitor

둘 이상의 프로세스/스레드가 공유자원에 안전하게 접근할 수 있게, 공유자원을 숨기고 해당 접근에 대해 인터페이스만 제공

- 한번에 하나의 프로세스만 모니터에서 활동하도록 보장
- 프레임워크/라이브러리 그 자체에서 제공하므로 가볍고 빠름
- 하나의 데이터마다 하나의 모니터 결합 가능, 모니터는 그것이 결합된 데이터가 **동시에 두 개 이상의 스레드에 의해 접근할 수 없게 막는 잠금 기능 제공**

<br>

![image](https://github.com/zeunxx/algorithm/assets/81572478/2ff536fa-435a-4aaa-8d38-4f6f27ffe80c)

모니터는 모니터 큐를 통해 공유 자원에 대한 작업들을 순차 처리
- 모니터는 세마포어보다 구현이 쉽고, 상호배제가 자동이다. 반면 세마포어는 상호배제를 명시적으로 구현해야 한다.