# 스레드와 멀티스레딩

## 스레드

프로세스의 실행 가능한 가장 작은 단위, CPU 수행의 기본 단위
- 프로세스는 여러 스레드를 가질 수 있음

![image](https://github.com/zeunxx/algorithm/assets/81572478/9e97e0b1-3d48-4b94-975a-60da54d34ea6)

- 프로세스는 코드, 데이터, 스택, 힙을 각각 생성


- 스레드는 코드, 데이터, 힙은 스레드끼리 공유하고 그 외의 영역(**스택, 자신의 레지스터 상태**)은 각각 생성

- 싱글 스레드: 한 프로세스가 하나의 스레드를 이용해 한 작업만 수행하는 것
- 멀티 스레드: 한 프로세스가 여러 스레드로 동시에 여러 작업을 수행하는 것
- 프로세스 내의 스레드는 모두 각각 독립적인 실행 파일이며, 모든 스레드는 프로세스의 일부

<br>

**✅ 스레드를 사용하는 이유**
- 프로세스를 생성하거나 프로세스간 문맥 교환 작업은 너무 무겁고 잦으면 성능 저하가 발생하는데, 스레드를 생성하거나 스레드간 문맥 교환은 그에 비해 가벼움
- 두 프로세스가 하나의 데이터를 공유하려면 IPC를 사용해야 하는데, 스레드간 통신보다 효율이 떨어짐

<br>
<br>

## 멀티 스레딩

멀티 스레딩은 프로세스 내의 작업을 여러개의 스레드, 멀티 스레드로 처리하는 기법.

프로세서(CPU)가 여러개인 경우 멀티 스레드를 통해 **병렬성**을 높일 수 있다 
= 여러 작업이 동시에 수행될 수 있다.
= **프로세스의 스레드들이 각각 다른 프로세서에서 병렬적으로 수행될 수 있기 때문이다.**
- 병렬성은 CPU의 개수에 비례

<BR>

프로세서가 하나인 경우 멀티 스레드를 통해 **동시성**을 높일 수 있다 
= **실제로는 각각의 시간에 한 작업만 수행되지만, 병렬적으로 수행되는 것처럼 보이는 것**
- 한 스레드가 block되더라도 커널이 다른 스레드로 switch 시켜 실행할 수 있어서 하나의 프로세서임에도 불구하고 빠른 처리가 가능하고 계산 속도가 증가함

<br>

### 멀티 스레딩의 장점

**1. 응답성**

싱글 스레드의 경우, 작업이 끝나기 전까지 사용자에게 응답X

멀티 스레드의 경우, 작업을 분리해서 수행하므로 실시간으로 사용자에게 응답할 수 있음


<BR>

**2. 자원 공유**

프로세스는 오직 IPC를 이용해서 자원을 공유하지만, 스레드는 자신이 속한 프로세스 내의 스레드들과 메모리나 자원을 공유해 효율적으로 사용할 수 있음


<BR>

**3. 경제성**

프로세스를 새로 생성하는 비용보다 스레드를 새로 생성하는 것이 훨씬 쌈

문맥교환의 오버헤드도 스레드가 더 경제적

= 따리사 멀티 프로세스보다 응답시간이 빠르다


<BR>

**4. 확장성**
싱글 스레드의 경우 한 프로세스는 오직 한 프로세서에서만 수행 가능

멀티 스레드의 경우 한 프로세스를 여러 프로세서에서 수행할 수 있으므로 훨씬 효율적



<BR>

### 멀티 스레딩의 단점

**1. 안정성**
멀티 프로세스 모델에서는 각 프로세스가 독립적으로 동작하므로 하나의 프로세스에서 문제가 발생해도 다른 프로세스들은 영향을 받지 않기 때문에 프로그램이 죽지 않고 계속 동작한다.

but, 멀티 스레드 모델에선 기본적으로 하나의 스레드에서 문제가 발생하면 다른 스레드들도 영향을 받아 전체 프로그램이 종료될 수 있다.

- 스레드에서 에러가 발생한다면 이에 대한 적절한 예외처리를 한다든지, 에러 발생시 새로운 스레드를 생성하거나 스레드 풀에서 잔여 스레드를 가져오던지 하여 프로그램 종료를 방지할 수 있다.
  - 새로운 스레드 생성 혹은 놀고있는 스레드 처리에 추가 비용이 발생하게 된다.



<br>

**2. 동기화로 인한 성능 저하**
멀티 스레드 모델은 여러개의 스레드가 공유자원에 동시에 접근할 수 있으므로, 동기화 문제가 발생할 수 있다. 

예를 들어 여러 스레드가 동시에 한 자원을 변경한다면 의도하지 않은 엉뚱한 값을 읽어 서비스에 치명적인 버그를 만들 수 있다. 따라서, **스레드간 동기화**는 데이터 접근을 제어하기 위한 필수 기술이다. 
- 동기화 작업은 여러 스레드들의 자원에 대한 접근을 순차적으로 통제하는 것이다. but, 동기화 작업은 여러 스레드 접근을 제한하므로 **병목 현상**이 일어나 성능이 저하될 가능성이 있다 

<br>

**3. 문맥교환 오버헤드**

멀티 프로세스보단 멀티 스레드가 문맥교환 오버헤드가 작긴 하지만 그래도 이 비용 자체를 무시할 수는 없다.

특히 스레드 수가 많으면 그만큼 문맥교환이 많이 발생하게 되고 이는 성능 저하로 이어진다. 

<br><br>

## 스레드 종류


![image](https://github.com/zeunxx/algorithm/assets/81572478/6b5f793e-a96d-4ea5-8134-09f1e5e0dd9d)


### 1️⃣ kernel thread

커널 레벨에서 생성되는 스레드로 커널이 스레드에 관련된 모든 작업을 직접 관리
- 커널 스레드를 사용하면 안정적이지만 유저모드에서 커널모드로 바꾸어야 한다.
- 커널이 프로세스 내에 모든 스레드에 대해 다 알고있기 때문에 스케쥴러는 적은 개수의 스레드를 가진 프로세스보다 많은 개수의 스레드를 가진 프로세스에 더 많은 시간 분배 가능
- kernel thread는 blocking이 빈번한 애플리케이션에서 사용하면 좋다.
- 커널에서 모든 프로세스뿐만 아니라 스레드까지 생성/관리하므로 커널의 복잡도가 높아지고 그로인한 오버헤드 발생
- **커널 내부에 process table, thread table 존재**
- OneToOne 모델, ManyToMany 모델 존재


- 장점
  - 모든 스레드가 system call로 구현 가능
  - 커널이 직접 스레드와 관련된 모든 작업을 개별적으로 처리
    - 프로세스 내 스레드 병렬 수행 가능
    - 하나의 스레드가 block되어도 다른 스레드는 계속 작업 가능
- 단점
  - OS에 의해 관리되므로 문맥교환시 커널모드↔유저모드 전환으로 인해 user thread에 비해 시간이 오래 걸림


<br>

### 2️⃣ user thread

커널이 생성해 주는게 아닌 라이브러리를 이용해서 생성한 스레드
- 커널 위에서 커널의 자원 없이 유저 수준의 스레드 라이브러리가 관리하는 스레드
- 커널은 프로세스 내 user thread를 알지 못함
- **커널에는 process table만 있고 각 프로세스 내부에 thread table 존재**
- 커널은 프로세스 단위로 자원을 할당하므로, 스레드 block → 프로세스 block → **프로세스 내 다른 스레드도 block**


<br><br>

### Multi-threading Model


![image](https://github.com/zeunxx/algorithm/assets/81572478/8142e9f7-09cc-42df-9a32-56386818046d)


**1. Many To One 모델**

하나의 커널 스레드에 여러 유저 스레드를 연결하는 모델

유저 공간이 스레드 라이브러리를 통해 스레드가 관리되므로 효율적
  - 라이브러리를 위한 코드나 자료구조가 유저공간에 존재하므로 시스템 콜이 아닌 지역함수를 콜하는 것이기 때문
  - BUT, 한번에 한 유저 스레드만 커널에 접근할 수 있어 여러 스레드의 병렬적 수행 불가
    - 한 유저 스레드의 시스템 콜로인해 block 되면 커널 스레드 자체가 block
    - 요즘에는 거의 사용 x


<br>


![image](https://github.com/zeunxx/algorithm/assets/81572478/17774fad-9186-42de-afae-8d08d02bfa8f)


**2. One To One 모델**

하나의 커널 스레드에 하나의 유저 스레드가 대응하는 모델

동시성을 높여주고, 멀티 프로세서 시스템에서 동시에 여러 스레드를 수행할 수 있도록 해줌
- BUT, 유저 스레드를 늘리면 커널 스레드도 똑같이 늘어나는데, 커널 스레드의 생성은 오버헤드가 크므로 성능 저하가 발생할 수 있음
- 하나의 프로세서에서만 가진 하나의 하드웨어에서 하나의 스레드가 block 되면 다른 스레드를 돌릴 수 있다.

<br>

![image](https://github.com/zeunxx/algorithm/assets/81572478/f76c2224-3c90-4850-8af4-d2f1b4b6e97d)


**3. Many To Many 모델**

여러 유저 스레드에 더 적거나 같은 수의 커널 스레드가 대응하는 모델

완전한 동시성은 아니지만, Many To One 모델에 비해 더 높은 동시성을 가지며, One To One 모델의 단점이었던 커널 스레드 생성의 오버헤드도 걱정할 필요가 없다.
- user thread가 block 되어 연결된 kernel thread가 block 되어도, 다른 user thread를 다른 kernel thred로 매핑해 대기 상태에 빠지는 것 해결


<br><br>


> thread pool
>
> 스레드를 요청할 때마다 새로운 스레드를 생성/수행/삭제를 반복하면 성능이 저하된다. 
> 따라서 미리 스레드 풀에 여러 스레드를 만들어두고 요청이 오면 스레드 풀에 기존에 존재하던 스레드를
> 할당해주는 방법을 사용한다.
>
> 새 스레드를 만드는 것보다 기존에 존재하는 스레드를 사용하는 것이 약간 더 빠르고, 많은 양의 스레드를 일정한 크기의 pool 안에 묶어둘 수 있다는 장점 존재