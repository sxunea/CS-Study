# PCB

운영체제에서 프로세스에 대한 메타 데이터를 저장한 데이터

= 특정 프로세스에 대한 정보를 담고 있는 자료구조

<br>

운영체제는 **PCB에 담긴 프로세스 정보를 이용해 프로세스를 관리하고 제어**

<BR>

- **프로세스가 생성될 때마다 고유의 PCB가 생성**되어 메인 메모리에 유지되고, **프로세스가 완료되면 제거**된다.
- 프로세스의 중요한 정보를 포함하고 있으므로 일반 사용자가 접근하지 못하게 커널 스택의 가장 앞부분에서 관리한다.
- 과정
    - 프로그램 실행
    - 프로세스 생성
    - 프로세스 주소 공간(코드, 데이터, 스택) 생성
    - 위 프로세스의 메타데이터들이 PCB에 저장
- 관리 방식: 연결리스트 방식
    - 삽입/삭제가 용이

<BR>

## PCB 구조

![image](https://github.com/sxunea/CS-Study/assets/81572478/bd26a87d-3b41-4c7e-b434-37dccdc83988)

- 포인터: 프로세스의 현재 위치를 저장하는 포인터 정보
- 프로세스 상태: 프로세스의 각 상태를 저장
    - 생성, 준비, 실행, 대기, 종료
- 프로세스 번호: 프로세스 고유의 ID (PID)
- 프로그램 카운터 PC: 프로세스를 위해 실행될 다음 명령어의 주소를 포함하는 카운터
- 레지스터: 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
- 메모리 제한: 운영체제에서 사용하는 메모리 관리 시스템에 대한 정보
    - 페이지 테이블, 세그먼트 테이블 등
- 열린 파일 목록


➕ 운영체제는 빠르게 PCB에 접근하기 위해 **프로세스 테이블**을 사용해 각 프로세스의 PCB 관리

<BR><BR>

## Context Switching 문맥교환

CPU가 현재 작업중인 프로세스에 대해 다른 프로세스로 넘어갈때 지금까지의 프로세스 상태를 저장하고, 새 프로세스의 저장된 상태를 다시 적재하는 작업

- PCB를 교환하는 과정
- 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생

<BR>

**멀티태스킹** : 실행 가능한 프로세스들이 운영체제의 스케줄러에 의해 조금씩 번갈아 수행되는 것
- 번갈아가며 프로세스가 CPU를 할당받는데, 이때 문맥교환 발생

<BR>

### 오버헤드

**문맥교환에 소요되는 시간과 메모리**


문맥교환이 발생하면 시간과 메모리가 소요되므로 잦은 문맥교환은 성능 저하를 가져온다.


I/O 이벤트가 발생했을때, 해당 이벤트가 끝날때까지 기다리면 CPU를 점유해도 아무런 작업도 할 수 없으므로 CPU가 낭비된다.
따라서 오버헤드를 감수하면서 기존 프로세스를 새 프로세스로 바꾸는 것이 효율적이다.


또한 멀티태스킹에서 시간 할당량이 적어지면 문맥교환의 수와 오버헤드가 증가하지만 동시에 더 많은 프로세스를 수행할 수 있고, 시간 할당량이 커지면 문맥교환의 수와 오버헤드는 감소하지만 더 적은 프로세스를 동시에 수행할 수 있다.
- 적절한 시간 할당량 분배가 중요



### 문맥교환 시나리오

![image](https://github.com/sxunea/CS-Study/assets/81572478/b1c90d9c-230a-4c65-8607-f6eb153640bd)


1. P0 프로세스가 인터럽트를 받으며 PCB0에 P0 프로세스의 상태정보 저장
2. 다음에 수행될 P1 프로세스의 PCB1에서 P1 프로세스의 정보를 CPU에 재로딩
3. P1 프로세스를 일정시간 수행
4. P1 프로세스가 인터럽트를 받으며 PCB1에 P1 프로세스의 상태정보 저장
5. 다음에 수행할 P0 프로세스의 PCB0에서 P1 프로세스의 상태정보가 CPU에 재로딩
6. P0 프로세스 일정시간 수행


<BR>

- idle time 유휴시간: 문맥교환이 발생할때 발생하는 시간 = 오버헤드
- 캐시미스 : 문맥교환이 일어날때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소변환이 생김 ➡️ 캐시 클리어 = 오버헤드


<br>

**스레드에서의 문맥교환**

스레드는 스택영역을 제외한 모든 메모리를 공유하므로 스레드간 문맥교환은 비용과 시간이 적게 듦