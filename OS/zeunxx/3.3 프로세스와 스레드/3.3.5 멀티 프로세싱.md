# 멀티 프로세싱

멀티 프로세싱은 여러개의 '프로세스', 즉 멀티 프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것

- 하나 이상의 일을 병렬로 처리 가능
- 특정 프로세스의 메모리, 프로세스 중 일부에 문제가 발생해도 다른 프로세스를 이용해 처리할 수 있어 신뢰성이 높음

<br>

## 웹 브라우저

웹 브라우저는 멀티 프로세스 구조

###  웹 브라우저 구조

- 브라우저 프로세스: 주소 표시줄, 북마크 막대, 뒤로가기 버튼, 앞으로 가기 버튼 등을 담당하며, 네트워크 요청이나 파일 접근 같은 권한 담당
- 렌더러 프로세스: 웹 사이트가 '보이는' 부분의 모든 것 제어
- 플러그인 프로세스: 웹 사이트에서 사용하는 플러그인 제어
- GPU 프로세스: GPU를 이용해서 화면을 그리는 부분을 제어


<BR>

## IPC

멀티프로세스는 IPC(Inter Process Communication)이 가능

<BR>

**IPC**: 프로세스끼리 **데이터를 주고받고** 공유 데이터를 관리하는 메커니즘
- 프로세스는 독립적으로 실행되는데, 이 프로세스간 통신에 사용되는 기법
- 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간의 통신 가능


<BR>

![image](https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/9b437f59-c01d-4fd5-82a0-e6a4cd7d3e92)
- 사용자가 사용하는 프로세스는 모두 유저공간user-space에서 개별 OS로부터 할당받은 독립된 공간에서 운영됨
- 프로세스는 독립된 공간에서 운영되므로 서로간의 통신이 어려움
- 이를 위해 커널 영역kernel-space에서 IPC를 통해 프로세스간 통신 제공

<BR>

### IPC 종류

**1️⃣ PIPE**

파이프는 두 개의 프로세스를 연결. 하나의 프로세스는 *쓰기*만 하고, 다른 프로세스는 데이터를 *읽기*만 한다.
- 부모 자식간의 **단방향 통신**으로 자주 사용 
- 파이프는 반이중 통신이기에 하나의 통신 선로는 읽/쓰기만 가능하므로, 만약 읽기/쓰기(송/수신)을 모두 하길 원한다면 두 개의 파이프를 만들어야 한다.
- read()와 write()가 기본적으로 block mode로 작동되므로 프로세스가 read 대기중이라면 read가 끝나기 전에는 write 불가

<br>

- 장점: 단순하다.
- 단점
    - full-duplex 통신 방식으로 활용하려면 pipe를 두개 만들어야 함 = 구현 복잡
    - buffer가 상대적으로 작아 overflow될 확률이 높다(read 처리를 빠르게 해야한다.)
    - 부모 자식 관계의 프로세스들 사이에서 가능'

<br><Br>

**😶 named pipe vs unamed pipe(anonymous pipe)**
- 익명파이프: 외부 프로세스에서 이 파이프 사용 불가 = 부모 프로세스가 자식 프로세스를 생성하는 경우에 파일지정번호를 상속받아 통신 가능 = **부모-자식 프로세스간에만 사용 가능**
- 네임드파이프: **외부 프로세스와 통신** 가능. 각 파이프에 이름과 권한을 부여해 파이프 생성 ex) 서버용 파이프 & 클라이언트용 파이프


<br>

>익명 파이프(PIPE)는 데이터 통신을 할 프로세스가 명확하게 알 수 있을 때 사용
>송신할 프로세스는 수신할 프로세스를 알고, 수신할 프로세스는 송신할 프로세스를 아는 경우
>가장 대표적인 예가 부모프로세스와 자식프로세스간에 데이터 통신을 하고자 할 때 
>부모 프로세스와 자식 프로세스는 서로를 명확히 알고 있으므로 굳이 파이프에 이름을 줄 필요가 없을 것이다
>
>반면, 자식과 부모 관계가 아닌 전혀 모르는 프로세스들 사이에서 pipe를 이용해서 통신을 해야하는 경우는 
>우리가 생판 모르는 사람과 대화를 하려면 이름을 알아야 하듯 pipe에 이름을 주어져야 한다.
>그것이 Named PIPE를 만든 이유이다

<br><Br>

**2️⃣ Message Queue**

메시지를 큐 데이터 구조 형태로 관리하는 기술

- Queue를 사용하므로 기본적으로 FIFO 방식. 먼저 들어온 메시지를 먼저 수신
    - 메시지 큐의 msgtype에 따라 특정 메시지를 먼저 수신할 수 있음
- 입출력 방식은 pipe와 동일하지만 pipe는 **데이터 흐름**이라면 message queue는 **메모리 공간** = 메모리를 사용한 pipe
- message queue에 쓸 데이터에 번호를 붙여 다수의 프로세스가 동시에 데이터를 쉽게 다룰 수 있음


<br><Br>

**😶 pipe vs message queue**
- 메시지 큐는 부모/자식 관계가 아니라, 어느 프로세스간에 데이터 통신 가능
- pipe는 byte 단위로 데이터 가져감(원하는 만큼) = stream oriented, message queue는 message/packet 단위로 데이터 가져감 = message oriented
- message queue는 양쪽에서 전송/수신 가능