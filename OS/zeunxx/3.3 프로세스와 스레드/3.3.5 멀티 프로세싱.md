# 멀티 프로세싱

멀티 프로세싱은 여러개의 '프로세스', 즉 멀티 프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것

- 하나 이상의 일을 병렬로 처리 가능
- 특정 프로세스의 메모리, 프로세스 중 일부에 문제가 발생해도 다른 프로세스를 이용해 처리할 수 있어 신뢰성이 높음

<br>

## 웹 브라우저

웹 브라우저는 멀티 프로세스 구조

###  웹 브라우저 구조

- 브라우저 프로세스: 주소 표시줄, 북마크 막대, 뒤로가기 버튼, 앞으로 가기 버튼 등을 담당하며, 네트워크 요청이나 파일 접근 같은 권한 담당
- 렌더러 프로세스: 웹 사이트가 '보이는' 부분의 모든 것 제어
- 플러그인 프로세스: 웹 사이트에서 사용하는 플러그인 제어
- GPU 프로세스: GPU를 이용해서 화면을 그리는 부분을 제어


<BR>

## IPC

멀티프로세스는 IPC(Inter Process Communication)이 가능

<BR>

**IPC**: 프로세스끼리 **데이터를 주고받고** 공유 데이터를 관리하는 메커니즘
- 프로세스는 독립적으로 실행되는데, 이 프로세스간 통신에 사용되는 기법
- 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간의 통신 가능


<BR>

![image](https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/9b437f59-c01d-4fd5-82a0-e6a4cd7d3e92)
- 사용자가 사용하는 프로세스는 모두 유저공간user-space에서 개별 OS로부터 할당받은 독립된 공간에서 운영됨
- 프로세스는 독립된 공간에서 운영되므로 서로간의 통신이 어려움
- 이를 위해 커널 영역kernel-space에서 IPC를 통해 프로세스간 통신 제공

<BR>

### IPC 종류

**1️⃣ PIPE**

파이프는 두 개의 프로세스를 연결. 하나의 프로세스는 *쓰기*만 하고, 다른 프로세스는 데이터를 *읽기*만 한다.
- 부모 자식간의 **단방향 통신**으로 자주 사용 
- 파이프는 반이중 통신이기에 하나의 통신 선로는 읽/쓰기만 가능하므로, 만약 읽기/쓰기(송/수신)을 모두 하길 원한다면 두 개의 파이프를 만들어야 한다.
- read()와 write()가 기본적으로 block mode로 작동되므로 프로세스가 read 대기중이라면 read가 끝나기 전에는 write 불가

<br>

- 장점: 단순하다.
- 단점
    - full-duplex 통신 방식으로 활용하려면 pipe를 두개 만들어야 함 = 구현 복잡
    - buffer가 상대적으로 작아 overflow될 확률이 높다(read 처리를 빠르게 해야한다.)
    - 부모 자식 관계의 프로세스들 사이에서 가능'

<br><Br>

**😶 named pipe vs unamed pipe(anonymous pipe)**
- 익명파이프: 외부 프로세스에서 이 파이프 사용 불가 = 부모 프로세스가 자식 프로세스를 생성하는 경우에 파일지정번호를 상속받아 통신 가능 = **부모-자식 프로세스간에만 사용 가능**
- 네임드파이프: **외부 프로세스와 통신** 가능. 각 파이프에 이름과 권한을 부여해 파이프 생성 ex) 서버용 파이프 & 클라이언트용 파이프


<br>

>익명 파이프(PIPE)는 데이터 통신을 할 프로세스가 명확하게 알 수 있을 때 사용
>송신할 프로세스는 수신할 프로세스를 알고, 수신할 프로세스는 송신할 프로세스를 아는 경우
>가장 대표적인 예가 부모프로세스와 자식프로세스간에 데이터 통신을 하고자 할 때 
>부모 프로세스와 자식 프로세스는 서로를 명확히 알고 있으므로 굳이 파이프에 이름을 줄 필요가 없을 것이다
>
>반면, 자식과 부모 관계가 아닌 전혀 모르는 프로세스들 사이에서 pipe를 이용해서 통신을 해야하는 경우는 
>우리가 생판 모르는 사람과 대화를 하려면 이름을 알아야 하듯 pipe에 이름을 주어져야 한다.
>그것이 Named PIPE를 만든 이유이다

<br><Br>

**2️⃣ Message Queue**

메시지를 큐 데이터 구조 형태로 관리하는 기술

- Queue를 사용하므로 기본적으로 FIFO 방식. 먼저 들어온 메시지를 먼저 수신
    - 메시지 큐의 msgtype에 따라 특정 메시지를 먼저 수신할 수 있음
- 입출력 방식은 pipe와 동일하지만 pipe는 **데이터 흐름**이라면 message queue는 **메모리 공간** = 메모리를 사용한 pipe
- message queue에 쓸 데이터에 번호를 붙여 다수의 프로세스가 동시에 데이터를 쉽게 다룰 수 있음
- 각 메시지는 message type이 있으므로, 수신 프로세스는 어떤 유형의 메시지를 받을지 선택 가능

<br><Br>

**😶 pipe vs message queue**
- 메시지 큐는 부모/자식 관계가 아니라, 어느 프로세스간에 데이터 통신 가능
- pipe는 byte 단위로 데이터 가져감(원하는 만큼) = **pipe는 stream oriented**, message queue는 message/packet 단위로 데이터 가져감 = **message oriented**
- message queue는 양쪽에서 전송/수신 가능

<br><br>

**3️⃣ Shared Memory**

![image](https://github.com/zeunxx/algorithm/assets/81572478/bfcd92f9-1031-4942-b363-aa09dd05a95e)


같은 메모리 공간을 두 개 이상의 프로세스가 공유한는 것.

같은 메모리 공간을 사용하므로 이를 통해 데이터를 주고 받을 수 있고, 여러 프로세스가 메모리를 공유하므로 **동기화 필요**
- 기본적으로 각 프로세스의 메모리를 다른 프로세스가 접근할 수 없지만 공유 메모리를 통해 여러 프로세스가 하나의 메모리 공유
- IPC 방식 중 어떤 매개체를 통해 데이터를 주고받는 것이 아닌 메모리 자체를 공유하므로, 불필요한 데이터 복사의 오버헤드가 발생하지 않아 가장 빠름
- 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간 할당
  - 공유메모리가 각 프로세스에게 첨부(attach)하는 방식으로 작동 = 각 프로세스가 메모리 영역에 첨부
- 프로세스간 read, write 모두 필요할때 사용
- 대량의 정보를 다수의 프로세스에 배포 가능
- 하드웨어 관점에서 공유 메모리는 CPU가 접근할 수 있는 큰 랜덤 접근 메모리인 RAM을 가리키기도 함


<BR><BR>

**4️⃣ Socket**

Unix 도메인 소켓 또는 IPC 소켓은 동일한 호스트 운영체제에서 실행된느 프로세스간 데이터를 교환하기 위한 데이터 통신 엔드 포인트

- 네트워크 소켓 통신을 통해 데이터 공유
  - 데이터 교환을 위해 양쪽 PC에서 각각 임의의 포트를 정하고 해당 포트간의 대화를 통해 데이터 주고 받음
  - 각각 PC의 포트를 담당하는 소켓은 각각 하나의 프로세스
  - 즉 해당 프로세스는 임의의 포트를 맡아 데이터를 송수신하는 역할을 진행하는 프로세스
  - 각각의 PC에서 프로세스를 통해 타 PC 포트에 연결하라는 명령을 보내면 두 프로세스는 서로 확인 과정을 거쳐 연결을 진행하고, pipe와 같이 1대1로 데이터 주고받음
- 클라이언트와 서버가 소켓을 통해 통신하는 구조로, 원격에서 프로세스간 데이터 공유시 사용
- Full Duplex (양방향) 통신 가능
- 서버-클라이언트 환경 구축에 용이
  