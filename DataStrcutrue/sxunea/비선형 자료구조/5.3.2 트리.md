# 5.3.2 트리
**트리**는 그래프에 속해있는 자료구조로, 정점과 간선으로 이루어진 나무를 거꾸로 한 모양을 가진다. 하나의 루트 노드와 0개 이상의 하위 트리로 이루어져 있고, 트리 안에 또 다른 트리를 가질 수 있는 **재귀적** 자료구조이기도 하다. 

또, 노드 간에 부모 자식 관계를 갖고 있는 **계층적** 자료구조이다. 서로 다른 두 노드를 연결하는 간선은 오직 하나이므로, **간선수는 노드 수 -1**이다.

## 트리의 종류

### 편향 트리 (skew tree)
모든 노드들이 자식을 하나만 가진 트리이다
### 이진 트리 (Binary Tree)
각 노드의 차수(자식 노드 수)가 2 이하인 트리이다

### 이진 탐색 트리 (Binary Search Tree, BST)
순서화된 이진트리로 노드의 왼쪽 자식의 값은 부모보다 작고, 오른쪽 자식은 부모보다 큰 값을 가진다

### m원 탐색 트리 (m-way Search Tree)
최대 m개의 서브 트리를 갖는 탐색 트리로, 이진 탐색 트리의 확장된 형태로 트리의 높이를 줄이기 위해 사용된다


### 균형 트리 (Balanced Tree, B-Tree)
m원 탐색 트리에서 높이 균형을 유지하는 트리이다

## 트리의 순회
![트리순회](https://github.com/sxunea/playground/assets/81434152/044169f9-8f43-4fbb-b707-df9806face40)

- **전위 순회**(pre order) : 루트 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식노드

        위 그림에서는 1-2-4-5-8-9-10-11-3-6-7-13-14

- **중위 순회**(in order) : 왼쪽 자식 노드 -> 루트 노드 -> 오른쪽 자식노드

        위 그림에서는 8-4-9-2-10-5-11-1-6-13-3-14-7

- **후위 순회**(post order) : 오른쪽 자식 노드 -> 루트 노드 -> 왼쪽 자식노드

        위 그림에서는 8-9-4-10-11-5-2-13-6-14-7-3-1

- **레벨 순회**(level order) : 루트 노드부터 계층적으로 

        위 그림에서는 1-2-3-4-5-6-7-8-9-10-11-13-14


## AVL 트리
AVL트리가 나온 이유도 Red-Black 트리와 동일한데 다른 점은 Balnce Factor(BF)를 통해 균형을 맞춘다.

- BF 값을 통한 균형은 rotation을 통해 이루어진다.
- rotation은 BF가 2 이상, -2 이하로 바뀐 노드를 기준으로 rotation이 이루어진다.
## 레드블랙 트리

![image](https://github.com/sxunea/CS-Study/assets/81434152/f9d56bcc-e0a1-4fa5-b56f-6807c83d19dd)

이진 검색 트리는 평균적으로 O(logN)의 삽입, 삭제, 검색 연산속도를 가진다. 이진 검색 트리의 구성 조건은 left < root < right 이런 조건에 따라서 랜덤한 데이터가 아닌 순차정렬 된 데이터가 들어올 때
이진 검색 트리는 편향 트리가 된다. 트리의 속도는 트리의 깊이에 따라 결정 되기에 편향 트리의 시간복잡도는 O(N)까지 늘어난다.
이러한 일을 방지하기 위해서 트리 깊이의 균형을 Red-Black 트리를 통해 맞출 수 있다.

## Red-Black vs AVL
AVL트리는 더욱 엄격한 균형을 이루고 있기 때문에 Red-Black 트리보다 더 빠른 조회를 제공

Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입 및 제거 작업을 수행
AVL트리는 각 노드에 대해 BF를 저장하므로 노드 당 int 저장이 필요
Red-Black 트리는 노드당 1비트의 정보만 필요합니다. 


Red-Black 트리는 맵, C++의 멀티캐스트, Java treeMap 등 대부분의 언어 라이브러리에서 사용, AVL트리는 더 빠른 검색이 필요한 데이터베이스에서 사용