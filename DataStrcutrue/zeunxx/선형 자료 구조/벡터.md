# 벡터 Vector

동적으로 요소를 할당할 수 있는 동적 배열
➡️ 배열과 매우 유사한데 크기가 정해진 배열을 극복하기 위한 배열

- 컴파일 시점에 개수를 모른다면 벡터를 써야 한다.
- 중복 허용, 순서 o, 랜덤 접근 가능(인덱스 가능)

<br>


- 탐색 및 맨 뒤 요소 삽입/삭제 : O(1)
    - 뒤에서 부터 삽입하는 push_back() : O(1)
- 맨 뒤 제외 요소 삽입/삭제 : O(n)


<br>

## 벡터의 구조와 특징

### 1️⃣ 단점

- 중간 삽입/삭제가 많은 상황에선 비효율적
    : 벡터는 배열과 매우 유사하다. 배열처럼 데이터를 주소 시작점부터 담는다. 따라서 중간에 값을 삽입/삭제하기 어렵다. (주소 값을 다 이동해야 하기때문, 하나씩 땡기거나 밀거나)

    <img width="381" alt="image" src="https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/d4185fbd-04ba-4902-b384-29193649b8f8">

- 다량의 데이터에서 검색이 느림 : 맨 앞에서부터 차례대로 값을 찾아가기 때문


<br>

###  2️⃣ 장점
- 맨 뒤에 삽입/삭제 쉬움
- 구현이 용이 
- 랜덤적으로 직접접근 가능 : 인덱스 사용


<br>

### 3️⃣ 벡터를 사용하는 경우

- 저장하려는 데이터 개수가 가변적일때
- 중간에 데이터를 삽입/삭제할 일이 없고, 대체로 마지막에 할때
- 저장할 데이터가 적을때 or 많다면 검색이 빈번하지 않을때
- 랜덤하게 데이터 접근을 허용하고 싶을때 


<br>

### 4️⃣ Java에서의 벡터

벡터는 ArrayList와 동일한 내부구조를 가진다.
ArrayList와 마찬가지로 Vector 내부에 값이 추가되면 자동으로 크기가 조절되며, 그 다음 객체들은 한 자리씩 뒤로 이동한다

<br>

- Vector가 ArrayList와 다른점 : Vector는 동기화 된 메소드로 구성되어 있으므로, 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드들이 실행할 수 있다.
    ➡️ 멀티스레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있다.

- Vector의 단점(ArrayList와 비교)
    : 벡터는 항상 동기화 되는 장점이자 단점을 가진다. 스레드가 1개일때도 동기화를 하므로 ArrayList보다 성능이 떨어진다.

- ArrayList : 기본적인 기능은 벡터와 동일하나 자동 동기화 기능이 빠져있고, 동기화 옵션이 존재한다.
    - 벡터에 비해 속도가 더 빨라 벡터에 비해 많이 쓰인다.