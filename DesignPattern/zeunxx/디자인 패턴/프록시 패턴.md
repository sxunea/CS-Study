# 프록시 패턴 Proxy Pattern

## 프록시 패턴이란?

대상 객체(subject)에 접근하기 전 그 접근에 대한 **흐름을 가로채** 대상 객체 앞단의 인터페이스 역할을 한다.


![image](https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/e15cc84a-2550-4b0d-83b9-373709680138)

이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용한다


> 💡 프록시 서버에서의 캐싱
>
> 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해
> 다시 저 멀리 있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것이다.
> 이를 통해 불필요하게 외부와 연결하지 않아 트래픽을 줄일 수 있다는 장점이 있다.


## 프록시 서버

프록시 서버는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 
접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.


### 프록시 서버로 쓰는 nginx

nginx는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버
- 주로 Node.js 서버 앞단의 프록시 서버로 활용 된다.
- 클라이언트로부터 요청을 받았을 때 요청에 맞는 정적 파일을 응답해주는 HTTP Web Server로 활용되기도 하고,
- 또는 Reverse Proxy Server로 활용하여 WAS의 부하를 줄일 수 있는 로드밸런서 역할을 하기도 합니다.
    - 로드밸런싱: 서버가 부담하는 부하를 분산하는 기술/장치


![image](https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/b1b3aeec-aa3f-4b71-899d-7599fc70d9bb)

그림처럼 nginx를 프록시 서버로 두어 실제 포트를 숨길 수 있고, 정적 자원을 gzip 압축하거나, 메인 서버 앞단에서의 로깅을 할 수 있다.


### 프록시 서버로 쓰는 CloudFlare

CloudFlare는 전 세계적으로 분산된 서버가 있고, 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스이다.
- CDN: Content Delivery Network의 약자인 CDN은 지리적 제약 없이 전 세계 사용자에게 빠르고 안전하게 콘텐츠를 전송할 수 있는 콘텐츠 전송 기술이다. 
    - 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크 → 콘텐츠 다운로드 시간 절약 가능


➡️ 웹 서버 앞단에 프록시 서버(CloudFlare)를 두어 DDOS 공격 방어, HTTPS 구축에 사용할 수 있다.

![image](https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/764ca3f3-c68b-4a0a-a06d-a9b0bc52dfb2)


#### 1. DDOS 공격 방어
DDOS는 짧은 기간동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형

CloudFlare는 의심스러운 트래픽, 특히 사용자가 접속하는 것이 아닌 시스템을 통해 오는 트래픽을 자동으로 차단해서 DDOS 공격으로 부터 보호한다.

CloudFlare의 거대한 네트워크 용량과 캐싱 전략으로 소규모 DDOS 공격은 쉽게 막아낼 수 있고, 이런 공격에 대한 방화벽 대시보드도 제공한다.


#### 2. HTTPS 구축

서버에서 HTTPS를 구축할때 인증서를 기반으로 구축할 수도 있지만, CloudFlare를 사용하면 별도의 인증서 설치 없이 구축 가능


#### 3. CORS 구축

- CORS : Cross Origin Resource Sharing은 서버가 웹 브라우저에서 리소스를 로드할때 다른 오리진(호스트 이름+포트)을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.

![image](https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/5889d297-309f-4501-b897-9a96524ea363)


- 주로 프론트엔드와 백엔드가 통신할때 CORS 에러가 발생한다.

프론트엔드에선 127.0.0.1:3000으로 테스팅하고 백엔드 서버는 127.0.0.1:12010이라면 **포트 번호가 달라** CORS 에러 발생

➡️ 이때, 프록시 서버를 투어 프론트엔드 서버에서 요청되는 오리진을 127.0.0.1:12010으로 바꾼다.

![image](https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/f75b32b1-e934-49ef-b8b3-3955cea65ce3)


---

정리하자면, 프록시로 인해 생기는 특징은 다음과 같다.

- 객체의 접근에 대해 사전 전처리를 할 수 있다.
- 본연에 코드를 그대로 유지할 수 있다.(필요한 기능에만 집중할 수 있다.)
- 본연 코드를 유지한 채 기능을 추가할 수 있다.
 

프록시 패턴의 의도는 위의 특징처럼, 해당 로직은 필요한 기능에만 집중하도록 하고, 부속적인 기능을 프록시를 통해 추가하는 것이다. 즉, 본연 코드의 로직을 바꾼다거나, 반환값을 바꾸는 것이 아니다. 


## 스프링에서의 프록시 패턴

### 스프링 AOP

AOP는 Aspect Oriented Programming의 약자로 관점 지향 프로그래밍이라고 불린다. 
관점 지향은 쉽게 말해 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다. 
- 모듈화: 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말한다. 

AOP에서 각 관점을 기준으로 로직을 모듈화한다는 것은 코드들을 부분적으로 나누어서 모듈화하겠다는 의미다. 
이때, 소스 코드상에서 **다른 부분에 계속 반복해서 쓰는 코드**들을 발견할 수 있는 데 
이것을 **흩어진 관심사 (Crosscutting Concerns)**라 부른다.

![image](https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/954524d1-25d5-45ec-baff-76984ccfda84)


➡️ 위와 같이 흩어진 관심사를 Aspect로 모듈화하고 **핵심적인 비즈니스 로직에서 분리하여 재사용**하겠다는 것이 AOP의 취지다.




💡 **AOP 간단히**
- 어플리케이션 전체에 걸쳐 사용되는 기능을 재사용하도록 지원
- 핵심적인 기능에서 부가적인 기능을 분리하여 Aspect라는 모듈로 만들어 설계하고 개발하는 방법이다.
- 각각의 클래스를 부가기능의 관점에서 바라보았을 때 공통된 요소를 추출하는것(로깅, 트랜잭션, 보안)
- 가로 영역의 공통된 부분을 잘라냈다고 하여, AOP를 크로스 컷팅(Cross-Cutting)이라고 부르기도 한다.


### 스프링 AOP with 프록시

대표적인 예제 : @Transaction

- service.class에서 메소드 윗단에 @Transaction만 추가하면 트랜잭션 실행되어 메소드 성공시 커밋, 실패시 롤백 된다.


![image](https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/77b2cd72-c625-411b-88b3-20a6238a9e07)

원래라면 쿼리(사진에선 function)를 수행하기전에, setAutoCommit = false, 쿼리 수행 후 commit or rollback 코드를 넣어준다


![image](https://github.com/zeunxx/Inflearn-Spring-RoadMap/assets/81572478/92b41149-e567-4987-ba54-aa74911c7edf)

프록시에서 사전 전처리로 위 내용을 수행해주어, 개발자는 핵심 로직에 집중할 수 있다.


- 출처
     - https://engkimbs.tistory.com/746
     - https://j-sik.tistory.com/107